// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: feed_follow.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const checkFeedFollowExistence = `-- name: CheckFeedFollowExistence :one
SELECT EXISTS (SELECT 1 FROM feed_follow WHERE user_id = $1 AND feed_id = $2)
`

type CheckFeedFollowExistenceParams struct {
	UserID uuid.UUID
	FeedID uuid.UUID
}

func (q *Queries) CheckFeedFollowExistence(ctx context.Context, arg CheckFeedFollowExistenceParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkFeedFollowExistence, arg.UserID, arg.FeedID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createNewFeedFollow = `-- name: CreateNewFeedFollow :one
INSERT INTO feed_follow (user_id, feed_id) VALUES ($1, $2) RETURNING id, user_id, feed_id, created_at, updated_at
`

type CreateNewFeedFollowParams struct {
	UserID uuid.UUID
	FeedID uuid.UUID
}

func (q *Queries) CreateNewFeedFollow(ctx context.Context, arg CreateNewFeedFollowParams) (FeedFollow, error) {
	row := q.db.QueryRowContext(ctx, createNewFeedFollow, arg.UserID, arg.FeedID)
	var i FeedFollow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FeedID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFeedFollowListByFeedId = `-- name: GetFeedFollowListByFeedId :many
SELECT feed_follow.id, feed_follow.user_id, feed_follow.feed_id, feed_follow.created_at, feed_follow.updated_at, feed.id, feed.user_id, feed.name, feed.url, feed.created_at, feed.updated_at
    FROM feed_follow
    JOIN public.feed on feed_follow.feed_id = feed.id
    WHERE feed_id = $1 ORDER BY feed_follow.created_at
`

type GetFeedFollowListByFeedIdRow struct {
	FeedFollow FeedFollow
	Feed       Feed
}

func (q *Queries) GetFeedFollowListByFeedId(ctx context.Context, feedID uuid.UUID) ([]GetFeedFollowListByFeedIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getFeedFollowListByFeedId, feedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeedFollowListByFeedIdRow
	for rows.Next() {
		var i GetFeedFollowListByFeedIdRow
		if err := rows.Scan(
			&i.FeedFollow.ID,
			&i.FeedFollow.UserID,
			&i.FeedFollow.FeedID,
			&i.FeedFollow.CreatedAt,
			&i.FeedFollow.UpdatedAt,
			&i.Feed.ID,
			&i.Feed.UserID,
			&i.Feed.Name,
			&i.Feed.Url,
			&i.Feed.CreatedAt,
			&i.Feed.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeedFollowListByUserId = `-- name: GetFeedFollowListByUserId :many
SELECT feed_follow.id, feed_follow.user_id, feed_follow.feed_id, feed_follow.created_at, feed_follow.updated_at, feed.id, feed.user_id, feed.name, feed.url, feed.created_at, feed.updated_at
    FROM feed_follow
    JOIN public.feed on feed_follow.feed_id = feed.id
    WHERE feed_follow.user_id = $1
    ORDER BY feed_follow.created_at
`

type GetFeedFollowListByUserIdRow struct {
	FeedFollow FeedFollow
	Feed       Feed
}

func (q *Queries) GetFeedFollowListByUserId(ctx context.Context, userID uuid.UUID) ([]GetFeedFollowListByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getFeedFollowListByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeedFollowListByUserIdRow
	for rows.Next() {
		var i GetFeedFollowListByUserIdRow
		if err := rows.Scan(
			&i.FeedFollow.ID,
			&i.FeedFollow.UserID,
			&i.FeedFollow.FeedID,
			&i.FeedFollow.CreatedAt,
			&i.FeedFollow.UpdatedAt,
			&i.Feed.ID,
			&i.Feed.UserID,
			&i.Feed.Name,
			&i.Feed.Url,
			&i.Feed.CreatedAt,
			&i.Feed.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeedFollowListPaginated = `-- name: GetFeedFollowListPaginated :many
SELECT id, user_id, feed_id, created_at, updated_at FROM feed_follow
`

func (q *Queries) GetFeedFollowListPaginated(ctx context.Context) ([]FeedFollow, error) {
	rows, err := q.db.QueryContext(ctx, getFeedFollowListPaginated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeedFollow
	for rows.Next() {
		var i FeedFollow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FeedID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
